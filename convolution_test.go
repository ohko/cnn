package cnn

import (
	"math"
	"testing"
)

// go test cnn -run TestConvolution -v -count=1
func TestConvolution(t *testing.T) {
	// Forward
	// input: 3x3x2
	// filter: 3x3x2 x2
	// output: 3x3x2

	// Backprop
	// input: 3x3x2
	// filter: 3x3x2 x2
	// output: 3x3x2

	c := NewConvolution(3, 3, 2, 2, 1)
	c.filters[0].SetData([][][]float64{
		{
			{1, 2, 3},
			{4, 5, 6},
			{7, 8, 9},
		},
		{
			{11, 22, 33},
			{44, 55, 66},
			{77, 88, 99},
		},
	})
	c.filters[1].SetData([][][]float64{
		{
			{0.1, 0.2, 0.3},
			{0.4, 0.5, 0.6},
			{0.7, 0.8, 0.9},
		},
		{
			{0.11, 0.22, 0.33},
			{0.44, 0.55, 0.66},
			{0.77, 0.88, 0.99},
		},
	})

	inputs := NewMatrix(3, 3, 2, nil)
	inputs.SetData([][][]float64{
		{
			{1, 2, 3},
			{4, 5, 6},
			{7, 8, 9},
		},
		{
			{11, 22, 33},
			{44, 55, 66},
			{77, 88, 99},
		},
	})

	/*
		[
			[636,1043,718]
			[1260,1931,1260]
			[718,1043,636]
		],
		[
			[636,1043,718]
			[1260,1931,1260]
			[718,1043,636]
		]
	*/
	chk := //
		[][][]float64{
			// 1
			{{(float64(0*1+0*2+0*3+0*4+1*5+2*6+0*7+4*8+5*9)/9.0 +
				(0*11+0*22+0*33+0*44+11*55+22*66+0*77+44*88+55*99)/9.0) / 2.0,
				//
				(float64(0*1+0*2+0*3+1*4+2*5+3*6+4*7+5*8+6*9)/9.0 +
					(0*11+0*22+0*33+11*44+22*55+33*66+44*77+55*88+66*99)/9.0) / 2.0,
				//
				(float64(0*1+0*2+0*3+2*4+3*5+0*6+5*7+6*8+0*9)/9.0 +
					(0*11+0*22+0*33+22*44+33*55+0*66+55*77+66*88+0*99)/9.0) / 2.0},

				//
				{(float64(0*1+1*2+2*3+0*4+4*5+5*6+0*7+7*8+8*9)/9.0 +
					(0*11+11*22+22*33+0*44+44*55+55*66+0*77+77*88+88*99)/9.0) / 2.0,
					//
					(float64(1*1+2*2+3*3+4*4+5*5+6*6+7*7+8*8+9*9)/9.0 +
						(11*11+22*22+33*33+44*44+55*55+66*66+77*77+88*88+99*99)/9.0) / 2.0,
					//
					(float64(2*1+3*2+0*3+5*4+6*5+0*6+8*7+9*8+0*9)/9.0 +
						(22*11+33*22+0*33+55*44+66*55+0*66+88*77+99*88+0*99)/9.0) / 2.0},

				//
				{(float64(0*1+4*2+5*3+0*4+7*5+8*6+0*7+0*8+0*9)/9.0 +
					(0*11+44*22+55*33+0*44+77*55+88*66+0*77+00*88+00*99)/9.0) / 2.0,
					//
					(float64(4*1+5*2+6*3+7*4+8*5+9*6+0*7+0*8+0*9)/9.0 +
						(44*11+55*22+66*33+77*44+88*55+99*66+00*77+00*88+00*99)/9.0) / 2.0,
					//
					(float64(5*1+6*2+0*3+8*4+9*5+0*6+0*7+0*8+0*9)/9.0 +
						(55*11+66*22+0*33+88*44+99*55+0*66+00*77+00*88+0*99)/9.0) / 2.0}},

			// 2
			{{((0*0.1+0*0.2+0*0.3+0*0.4+1*0.5+2*0.6+0*0.7+4*0.8+5*0.9)/9.0 +
				(0*0.11+0*0.22+0*0.33+0*0.44+11*0.55+22*0.66+0*0.77+44*0.88+55*0.99)/9.0) / 2.0,
				//
				((0*0.1+0*0.2+0*0.3+1*0.4+2*0.5+3*0.6+4*0.7+5*0.8+6*0.9)/9.0 +
					(0*0.11+0*0.22+0*0.33+11*0.44+22*0.55+33*0.66+44*0.77+55*0.88+66*0.99)/9.0) / 2.0,
				//
				((0*0.1+0*0.2+0*0.3+2*0.4+3*0.5+0*0.6+5*0.7+6*0.8+0*0.9)/9.0 +
					(0*0.11+0*0.22+0*0.33+22*0.44+33*0.55+0*0.66+55*0.77+66*0.88+0*0.99)/9.0) / 2.0},

				//
				{((0*0.1+1*0.2+2*0.3+0*0.4+4*0.5+5*0.6+0*0.7+7*0.8+8*0.9)/9.0 +
					(0*0.11+11*0.22+22*0.33+0*0.44+44*0.55+55*0.66+0*0.77+77*0.88+88*0.99)/9.0) / 2.0,
					//
					((1*0.1+2*0.2+3*0.3+4*0.4+5*0.5+6*0.6+7*0.7+8*0.8+9*0.9)/9.0 +
						(11*0.11+22*0.22+33*0.33+44*0.44+55*0.55+66*0.66+77*0.77+88*0.88+99*0.99)/9.0) / 2.0,
					//
					((2*0.1+3*0.2+0*0.3+5*0.4+6*0.5+0*0.6+8*0.7+9*0.8+0*0.9)/9.0 +
						(22*0.11+33*0.22+0*0.33+55*0.44+66*0.55+0*0.66+88*0.77+99*0.88+0*0.99)/9.0) / 2.0},

				//
				{((0*0.1+4*0.2+5*0.3+0*0.4+7*0.5+8*0.6+0*0.7+0*0.8+0*0.9)/9.0 +
					(0*0.11+44*0.22+55*0.33+0*0.44+77*0.55+88*0.66+0*0.77+00*0.88+00*0.99)/9.0) / 2.0,
					//
					((4*0.1+5*0.2+6*0.3+7*0.4+8*0.5+9*0.6+0*0.7+0*0.8+0*0.9)/9.0 +
						(44*0.11+55*0.22+66*0.33+77*0.44+88*0.55+99*0.66+00*0.77+00*0.88+00*0.99)/9.0) / 2.0,
					//
					((5*0.1+6*0.2+0*0.3+8*0.4+9*0.5+0*0.6+0*0.7+0*0.8+0*0.9)/9.0 +
						(55*0.11+66*0.22+0*0.33+88*0.44+99*0.55+0*0.66+00*0.77+00*0.88+0*0.99)/9.0) / 2.0}}}
	print3(true, "test", chk)

	out := c.Forward(inputs)
	print3(true, "out", out.Data)

	for d := range chk {
		for y := range chk[d] {
			for x := range chk[d][y] {
				if math.Abs(chk[d][y][x]-out.Data[d][y][x]) > 0.00001 {
					t.Fatal(chk[d][y][x], out.Data[d][y][x])
				}
			}
		}
	}

	out2 := c.Backprop(inputs, 0.6)
	print3(true, "out2", out2.Data)
}
